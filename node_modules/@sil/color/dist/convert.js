"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cmykToHsl = exports.cmykToHex = exports.hslToHex = exports.hsvToHex = exports.hslToCmyk = exports.hexToCmyk = exports.hsvToCmyk = exports.cmykToHsv = exports.hslToHsv = exports.hexToHsv = exports.hsvToHsl = exports.hsvToRgb = exports.rgbToHsv = exports.cmykToRgb = exports.rgbToCmyk = exports.rgbToHex = exports.rgbToHsl = exports.hslToRgb = exports.hexToHsl = exports.hexToRgb = exports.defaultValues = void 0;
const get_1 = require("./get");
const types_1 = require("./types");
exports.defaultValues = {
    hex: "#000000",
    rgb: { r: 0, g: 0, b: 0 },
    hsl: { h: 0, s: 0, l: 0 },
    hsv: { h: 0, s: 0, v: 0 },
    cmyk: { c: 0, m: 0, y: 0, k: 100 },
};
const hexToRgb = (hex) => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex) || Object.values(exports.defaultValues.rgb);
    return {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16),
    };
};
exports.hexToRgb = hexToRgb;
const hexToHsl = (hex) => {
    const rgb = (0, exports.hexToRgb)(hex);
    return {
        h: (0, get_1.getHue)(rgb),
        s: (0, get_1.getSaturation)(rgb),
        l: (0, get_1.getLightness)(rgb),
    };
};
exports.hexToHsl = hexToHsl;
const hslToRgb = (hsl) => {
    let { h, s, l } = hsl;
    s /= 100;
    l /= 100;
    const k = (n) => (n + h / 30) % 12;
    const a = s * Math.min(l, 1 - l);
    const f = (n) => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
    const rgb = {
        r: Math.round(255 * f(0)),
        g: Math.round(255 * f(8)),
        b: Math.round(255 * f(4)),
    };
    if ((0, types_1.instanceOfHSL)(hsl)) {
        return rgb;
    }
    else {
        return Object.assign(Object.assign({}, rgb), { a: hsl.a });
    }
};
exports.hslToRgb = hslToRgb;
const rgbToHsl = (rgb) => {
    const hsl = {
        h: (0, get_1.getHue)(rgb),
        s: (0, get_1.getSaturation)(rgb),
        l: (0, get_1.getLightness)(rgb),
    };
    if ((0, types_1.instanceOfRGB)(rgb)) {
        return hsl;
    }
    else {
        return Object.assign(Object.assign({}, hsl), { a: rgb.a });
    }
};
exports.rgbToHsl = rgbToHsl;
const rgbToHex = (rgb) => {
    const { r, g, b } = rgb;
    return "#" + (0, get_1.componentToHex)(r) + (0, get_1.componentToHex)(g) + (0, get_1.componentToHex)(b);
};
exports.rgbToHex = rgbToHex;
const rgbToCmyk = (rgb) => {
    let { r, g, b } = rgb;
    let c = 1 - r / 255;
    let m = 1 - g / 255;
    let y = 1 - b / 255;
    let k = Math.min(c, Math.min(m, y));
    c = (c - k) / (1 - k);
    m = (m - k) / (1 - k);
    y = (y - k) / (1 - k);
    c = Math.round(c * 100);
    m = Math.round(m * 100);
    y = Math.round(y * 100);
    k = Math.round(k * 100);
    c = isNaN(c) ? 0 : c;
    m = isNaN(m) ? 0 : m;
    y = isNaN(y) ? 0 : y;
    k = isNaN(k) ? 0 : k;
    const cmyk = {
        c: c,
        m: m,
        y: y,
        k: k,
    };
    return cmyk;
};
exports.rgbToCmyk = rgbToCmyk;
const cmykToRgb = (cmyk) => {
    const k = cmyk.k / 100;
    const c = (cmyk.c / 100) * (1 - k) + k;
    const m = (cmyk.m / 100) * (1 - k) + k;
    const y = (cmyk.y / 100) * (1 - k) + k;
    const r = Math.round(255 * (1 - c));
    const g = Math.round(255 * (1 - m));
    const b = Math.round(255 * (1 - y));
    const rgb = { r: r, g: g, b: b };
    return rgb;
};
exports.cmykToRgb = cmykToRgb;
const rgbToHsv = (rgb) => {
    const { r, g, b } = rgb;
    let h = 0, s = 0, v = 0;
    const rAbs = r / 255;
    const gAbs = g / 255;
    const bAbs = b / 255;
    v = Math.max(rAbs, gAbs, bAbs);
    const diff = v - Math.min(rAbs, gAbs, bAbs);
    const diffc = (c) => (v - c) / 6 / diff + 1 / 2;
    const percentRoundFn = (num) => (Math.round(num * 100) / 100) * 100;
    if (diff == 0) {
        h = s = 0;
    }
    else {
        s = diff / v;
        const rr = diffc(rAbs);
        const gg = diffc(gAbs);
        const bb = diffc(bAbs);
        if (rAbs === v) {
            h = bb - gg;
        }
        else if (gAbs === v) {
            h = 1 / 3 + rr - bb;
        }
        else if (bAbs === v) {
            h = 2 / 3 + gg - rr;
        }
        if (h < 0) {
            h += 1;
        }
        else if (h > 1) {
            h -= 1;
        }
    }
    const hsv = {
        h: Math.round(h * 360),
        s: percentRoundFn(s),
        v: percentRoundFn(v),
    };
    if (rgb.a !== undefined) {
        return Object.assign(Object.assign({}, hsv), { a: rgb.a });
    }
    return hsv;
};
exports.rgbToHsv = rgbToHsv;
const hsvToRgb = (hsv) => {
    const { h, s, v } = hsv;
    let f, p, q, t, r = 0, g = 0, b = 0;
    const i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0:
            (r = v), (g = t), (b = p);
            break;
        case 1:
            (r = q), (g = v), (b = p);
            break;
        case 2:
            (r = p), (g = v), (b = t);
            break;
        case 3:
            (r = p), (g = q), (b = v);
            break;
        case 4:
            (r = t), (g = p), (b = v);
            break;
        case 5:
            (r = v), (g = p), (b = q);
            break;
    }
    const rgb = {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255),
    };
    if (hsv.a !== undefined) {
        return Object.assign(Object.assign({}, rgb), { a: hsv.a });
    }
    return rgb;
};
exports.hsvToRgb = hsvToRgb;
const hsvToHsl = (hsv) => {
    const { h, s, v } = hsv;
    let sat = s;
    const l = ((2 - s) * v) / 2;
    if (l != 0) {
        if (l == 1) {
            sat = 0;
        }
        else if (l < 0.5) {
            sat = (s * v) / (l * 2);
        }
        else {
            sat = (s * v) / (2 - l * 2);
        }
    }
    const hsl = {
        h: h,
        s: sat,
        l: l,
    };
    if (hsv.a !== undefined) {
        return Object.assign(Object.assign({}, hsl), { a: hsv.a });
    }
    return hsl;
};
exports.hsvToHsl = hsvToHsl;
const hexToHsv = (src) => (0, exports.rgbToHsv)((0, exports.hexToRgb)(src));
exports.hexToHsv = hexToHsv;
const hslToHsv = (src) => (0, exports.rgbToHsv)((0, exports.hslToRgb)(src));
exports.hslToHsv = hslToHsv;
const cmykToHsv = (src) => (0, exports.rgbToHsv)((0, exports.cmykToRgb)(src));
exports.cmykToHsv = cmykToHsv;
const hsvToCmyk = (src) => (0, exports.rgbToCmyk)((0, exports.hsvToRgb)(src));
exports.hsvToCmyk = hsvToCmyk;
const hexToCmyk = (src) => (0, exports.rgbToCmyk)((0, exports.hexToRgb)(src));
exports.hexToCmyk = hexToCmyk;
const hslToCmyk = (src) => (0, exports.rgbToCmyk)((0, exports.hslToRgb)(src));
exports.hslToCmyk = hslToCmyk;
const hsvToHex = (src) => (0, exports.rgbToHex)((0, exports.hsvToRgb)(src));
exports.hsvToHex = hsvToHex;
const hslToHex = (src) => (0, exports.rgbToHex)((0, exports.hslToRgb)(src));
exports.hslToHex = hslToHex;
const cmykToHex = (src) => (0, exports.rgbToHex)((0, exports.cmykToRgb)(src));
exports.cmykToHex = cmykToHex;
const cmykToHsl = (src) => (0, exports.rgbToHsl)((0, exports.cmykToRgb)(src));
exports.cmykToHsl = cmykToHsl;
//# sourceMappingURL=convert.js.map