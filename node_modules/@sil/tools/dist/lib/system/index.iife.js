"use strict";
(() => {
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });

  // src/lib/system/file.ts
  var import_fs = __require("fs");
  var import_path = __require("path");

  // src/lib/default/async.ts
  async function asyncForEach(array, callback) {
    for (let index = 0; index < array.length; index++) {
      await callback(array[index], index, array);
    }
  }
  var asyncFilter = async (arr, predicate) => {
    const results = await Promise.all(arr.map(predicate));
    return arr.filter((_v, index) => results[index]);
  };
  var asyncSome = async (arr, predicate) => (await asyncFilter(arr, predicate)).length > 0;
  var asyncEvery = async (arr, predicate) => (await asyncFilter(arr, predicate)).length === arr.length;

  // src/lib/system/file.ts
  var { mkdir, readFile, access, writeFile, R_OK, F_OK, W_OK } = __require("fs").promises;
  var createDir = async (dir) => {
    try {
      !(0, import_fs.existsSync)(dir) && await mkdir(dir, { recursive: true });
    } catch (error) {
      console.error(error);
    }
  };
  var getFileData = async (filePath) => {
    try {
      const file = await readFile(filePath).then((res) => res.toString());
      return filePath.includes(".json") ? JSON.parse(file) : file;
    } catch (err) {
      throw Error(err);
    }
  };
  var getJsonData = async (filePath) => {
    const data = await getFileData(filePath);
    return JSON.parse(data);
  };
  var fileExists = async (path) => {
    try {
      await access(path, R_OK | W_OK | F_OK);
      return true;
    } catch {
      return false;
    }
  };
  var filesExist = async (paths, some = false) => {
    const action = some ? asyncSome : asyncEvery;
    try {
      const result = await action(
        paths,
        async (file) => await fileExists(file)
      );
      return result;
    } catch (err) {
      return false;
    }
  };
  var existingFiles = async (paths) => {
    const existingPaths = [];
    await asyncForEach(paths, async (path) => {
      const exists = await fileExists(path);
      if (exists)
        existingPaths.push(path);
    });
    return existingPaths;
  };
  var createFile = async (dest, data) => {
    await mkdir((0, import_path.dirname)(dest), { recursive: true });
    await writeFile(dest, data);
  };

  // src/lib/system/path.ts
  var parentPath = (path, goBack = -1) => path.split("/").slice(0, goBack).join("/");
  var renamePath = (ogLink, rename) => {
    const pathGroup = ogLink.split("/");
    pathGroup[pathGroup.length - 2] = rename;
    return pathGroup.join("/").toLowerCase();
  };

  // src/lib/system/fs.ts
  var { mkdir: mkdir2, readFile: readFile2, access: access2, writeFile: writeFile2, createWriteStream, existsSync: existsSync2 } = __require("fs").promises;
})();
//# sourceMappingURL=index.iife.js.map