"use strict";
(() => {
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });

  // src/lib/default/array.ts
  var repeat = (num = 1, value, toString = false) => {
    let values = [];
    for (let i = 0; i < num; i++) {
      values.push(value);
    }
    if (toString)
      return values.join("");
    else
      return values;
  };

  // src/lib/default/async.ts
  async function asyncForEach(array, callback) {
    for (let index = 0; index < array.length; index++) {
      await callback(array[index], index, array);
    }
  }
  var hello = async (args = {}) => {
    return args;
  };
  var promisify = async (func) => {
    await Promise.resolve(func).then(function() {
      return;
    });
  };
  var asyncFilter = async (arr, predicate) => {
    const results = await Promise.all(arr.map(predicate));
    return arr.filter((_v, index) => results[index]);
  };
  var asyncSome = async (arr, predicate) => (await asyncFilter(arr, predicate)).length > 0;
  var asyncEvery = async (arr, predicate) => (await asyncFilter(arr, predicate)).length === arr.length;

  // src/lib/default/number.ts
  var toRoundNumber = (num, decimalPlaces = 2) => {
    return Number(
      Math.round(parseFloat(num + "e" + decimalPlaces)) + "e-" + decimalPlaces
    ).toFixed(decimalPlaces);
  };

  // src/lib/default/strings.ts
  var removeTag = (input, tag) => {
    const regex = new RegExp(`<${tag}(.*)>(.*)</${tag}>`, "gi");
    return input.replace(regex, "");
  };
  var getStringFromTag = (input, tag) => {
    const regex = new RegExp(`<${tag}(.*?)>(.+?)</${tag}>`, "gi");
    const matches = regex.exec(input);
    return matches && matches.length > 1 ? matches[2] : "";
  };
  var getIndexes = (source, find) => {
    const result = [];
    let i = 0;
    while (i < source.length) {
      if (source.substring(i, i + find.length) === find) {
        result.push(i);
        i += find.length;
      } else {
        i++;
      }
    }
    return result;
  };
  var nthIndex = (source, find, nth) => {
    const result = getIndexes(source, find);
    return result[nth];
  };

  // src/lib/default/style.ts
  var Style = class {
    constructor(block) {
      this.block = "";
      this.block = block;
    }
    bem(element = "", modifier = "") {
      if (this.block == "") {
        return ``;
      }
      return `${this.block}${element ? `__${element}` : ``}${modifier ? `--${modifier}` : ``}`;
    }
  };

  // src/lib/system/file.ts
  var import_fs = __require("fs");
  var import_path = __require("path");
  var { mkdir, readFile, access, writeFile, R_OK, F_OK, W_OK } = __require("fs").promises;
  var createDir = async (dir) => {
    try {
      !(0, import_fs.existsSync)(dir) && await mkdir(dir, { recursive: true });
    } catch (error) {
      console.error(error);
    }
  };
  var getFileData = async (filePath) => {
    try {
      const file = await readFile(filePath).then((res) => res.toString());
      return filePath.includes(".json") ? JSON.parse(file) : file;
    } catch (err) {
      throw Error(err);
    }
  };
  var getJsonData = async (filePath) => {
    const data = await getFileData(filePath);
    return JSON.parse(data);
  };
  var fileExists = async (path) => {
    try {
      await access(path, R_OK | W_OK | F_OK);
      return true;
    } catch {
      return false;
    }
  };
  var filesExist = async (paths, some = false) => {
    const action = some ? asyncSome : asyncEvery;
    try {
      const result = await action(
        paths,
        async (file) => await fileExists(file)
      );
      return result;
    } catch (err) {
      return false;
    }
  };
  var existingFiles = async (paths) => {
    const existingPaths = [];
    await asyncForEach(paths, async (path) => {
      const exists = await fileExists(path);
      if (exists)
        existingPaths.push(path);
    });
    return existingPaths;
  };
  var createFile = async (dest, data) => {
    await mkdir((0, import_path.dirname)(dest), { recursive: true });
    await writeFile(dest, data);
  };

  // src/lib/system/path.ts
  var parentPath = (path, goBack = -1) => path.split("/").slice(0, goBack).join("/");
  var renamePath = (ogLink, rename) => {
    const pathGroup = ogLink.split("/");
    pathGroup[pathGroup.length - 2] = rename;
    return pathGroup.join("/").toLowerCase();
  };

  // src/lib/system/fs.ts
  var { mkdir: mkdir2, readFile: readFile2, access: access2, writeFile: writeFile2, createWriteStream, existsSync: existsSync2 } = __require("fs").promises;

  // src/lib/color/convert.ts
  var hexToRgb = (hex) => {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      red: parseInt(result[1], 16),
      green: parseInt(result[2], 16),
      blue: parseInt(result[3], 16)
    } : {
      red: 0,
      green: 0,
      blue: 0
    };
  };
  var componentToHex = (c) => {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
  };
  var rgbToHex = (rgb) => {
    const cth = componentToHex;
    return `#${cth(rgb.red)}${cth(rgb.green)}${cth(rgb.blue)}`;
  };
  var hexToHsl = (hex) => {
    return rgbToHsl(hexToRgb(hex));
  };
  var RgbToLuminance = (rgb) => {
    return 0.299 * rgb.red + 0.587 * rgb.green + 0.114 * rgb.blue;
  };
  var HexToLuminance = (hex) => RgbToLuminance(hexToRgb(hex));
  var hslToHex = (hsl) => {
    hsl.lightness /= 100;
    const a = hsl.saturation * Math.min(hsl.lightness, 1 - hsl.lightness) / 100;
    const f = (n) => {
      const k = (n + hsl.hue / 30) % 12;
      const color = hsl.lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      return Math.round(255 * color).toString(16).padStart(2, "0");
    };
    return `#${f(0)}${f(8)}${f(4)}`;
  };
  var rgbToHsl = (rgb) => {
    rgb.red /= 255, rgb.green /= 255, rgb.blue /= 255;
    const max = Math.max(rgb.red, rgb.green, rgb.blue);
    const min = Math.min(rgb.red, rgb.green, rgb.blue);
    let hue;
    let sat;
    let light = (max + min) / 2;
    if (max == min) {
      hue = sat = 0;
    } else {
      var d = max - min;
      sat = light > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case rgb.red:
          hue = (rgb.green - rgb.blue) / d + (rgb.green < rgb.blue ? 6 : 0);
          break;
        case rgb.green:
          hue = (rgb.blue - rgb.red) / d + 2;
          break;
        case rgb.blue:
          hue = (rgb.red - rgb.green) / d + 4;
          break;
      }
      if (hue)
        hue /= 6;
    }
    return { hue: hue || 0, saturation: sat, lightness: light };
  };

  // src/lib/color/mix.ts
  var mixHex = (colorA, colorB, amount) => {
    const colorA_array = colorA.match(/\w\w/g);
    const colorB_array = colorB.match(/\w\w/g);
    if (colorA_array == null || colorB_array == null)
      return "#000000";
    const [rA, gA, bA] = colorA_array.map((c) => parseInt(c, 16));
    const [rB, gB, bB] = colorB_array.map((c) => parseInt(c, 16));
    const rgb = {
      red: 0,
      green: 0,
      blue: 0
    };
    rgb.red = Math.round(rA + (rB - rA) * amount);
    rgb.green = Math.round(gA + (gB - gA) * amount);
    rgb.blue = Math.round(bA + (bB - bA) * amount);
    return rgbToHex(rgb);
  };
  var mixRGB = (colorA, colorB, amount) => {
    return hexToRgb(mixHex(rgbToHex(colorA), rgbToHex(colorB), amount));
  };
  var mixHSL = (colorA, colorB, amount) => {
    return hexToHsl(mixHex(hslToHex(colorA), hslToHex(colorB), amount));
  };
})();
//# sourceMappingURL=index.iife.js.map