"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.blockLoader = void 0;
const tools_1 = require("@sil/tools");
const types_1 = require("../types");
const settings_1 = require("../settings");
const util_1 = require("../util");
const blocks_line_1 = require("./blocks.line");
const blockLoader = (args = {}, settings = {}) => __awaiter(void 0, void 0, void 0, function* () {
    if (settings.logger === types_1.LoggerType.CONSOLE) {
        (0, util_1.logger)("Loader does not Work with Console.log");
        return;
    }
    let config = Object.assign({ message: "[percentage] [loader]", increment: 1, width: "100%", start: 0, end: 100, interval: 25, charFilled: "▒", charUnfilled: "░" }, args);
    let i = config.start;
    const countDown = config.start > config.end;
    const loadBar = () => {
        const width = config.width == "100%"
            ? (0, settings_1.getContentWidth)() - 7
            : ((config.end - config.start) *
                (typeof config.width == "string"
                    ? parseInt(config.width)
                    : config.width)) /
                100;
        const step = Math.round(((100 / i ? i : 1) * width) / 100);
        const filled = Math.floor(width - (width - step));
        let unfilled = Math.floor(width - step);
        if (filled + unfilled !== width)
            unfilled = unfilled + 1;
        const msg = `${(0, tools_1.repeat)(filled, config.charFilled, true)}${(0, tools_1.repeat)(unfilled, config.charUnfilled, true)}`;
        return msg;
    };
    const loaderAction = () => {
        (0, util_1.clear)();
        const loader = loadBar();
        const percentage = `${i}%`;
        let message = config.message
            .replace("[loader]", loader)
            .replace("[percentage]", (0, util_1.spacedText)(4, percentage));
        i = countDown ? i - config.increment : i + config.increment;
        (0, blocks_line_1.blockLine)(message, Object.assign(Object.assign({}, settings), { newLine: false }));
    };
    loaderAction();
    return yield new Promise((resolve) => {
        let count = setInterval(() => {
            loaderAction();
            const isEnding = countDown ? i >= config.end - 1 : i >= config.end + 1;
            if (isEnding) {
                (0, util_1.newLine)();
                resolve();
                clearInterval(count);
            }
        }, config.interval);
    });
});
exports.blockLoader = blockLoader;
//# sourceMappingURL=blocks.loader.js.map