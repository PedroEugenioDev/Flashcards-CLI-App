"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.blockCounter = void 0;
const types_1 = require("../types");
const util_1 = require("../util");
const blocks_line_1 = require("./blocks.line");
const blockCounter = (args = {}, settings = {}) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    if (settings.logger === types_1.LoggerType.CONSOLE) {
        (0, util_1.logger)("Counter does not Work with Console.log");
        return;
    }
    const config = Object.assign({ message: "My message [count] to go", increment: 1, start: 0, end: 100, interval: 100 }, args);
    // Define variables
    let i = config.start;
    let step = 0;
    const messageCount = ((_a = config.messages) === null || _a === void 0 ? void 0 : _a.length) || 0;
    const stepsCount = (config.start > config.end
        ? config.start - config.end + 1
        : config.end - config.start + 1) / config.increment;
    const doSteps = messageCount > 0 && messageCount === stepsCount;
    const countDown = config.start > config.end;
    // Prepare action
    const counterAction = () => {
        (0, util_1.clear)();
        let message = doSteps
            ? config.messages[step].replace("[count]", i.toString())
            : config.message.replace("[count]", i.toString());
        (0, blocks_line_1.blockLine)(message, Object.assign(Object.assign({}, settings), { newLine: i === config.end }));
        i = countDown ? i - config.increment : i + config.increment;
        doSteps && step++;
    };
    counterAction();
    // Do the Interval
    return yield new Promise((resolve) => {
        let count = setInterval(() => {
            counterAction();
            const isEnding = (countDown ? i === config.end - 1 : i === config.end + 1) ||
                (doSteps && step === stepsCount);
            if (isEnding) {
                // if (countDown) NEW_LINE();
                resolve();
                clearInterval(count);
            }
        }, config.interval);
    });
    // return;
});
exports.blockCounter = blockCounter;
//# sourceMappingURL=blocks.counter.js.map